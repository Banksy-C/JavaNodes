行为型模式
类和对象如何交互，及划分责任和算法
大致有四种：

父类与子类：策略模式、模板方法模式
两个类之间：观察者模式、迭代子模式、职责链模式、命令模式
类的状态：备忘录模式、状态模式
通过中间类：访问者模式、中介者模式，解释器模式

1、行为模式关注点"怎样运行对象/类"，所以我们关注类/对象的运行时流程控制。
2、行为模式用于描述程序在运行时复杂的流程控制，描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间的职责分配。
3、行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分配行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度更低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。


关注对象之间的通信。

模板方法模式：父类定义算法骨架，某些实现放子类
策略模式：每种算法独立封装，根据不同情况使用不同算法策略
状态模式：每种状态独立封装，不同状态内部封装了不同行为
命令模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开
责任链模式：所有处理者封装为链式结构，依次调用
备忘录模式：把核心信息抽取出来，可以进行保存
解释器模式：定义语法解析规则
观察者模式：维护多个观察者依赖，状态变化通知所有观察者
中介者模式：取消类/对象的直接调用关系，使用中介者维护
迭代器模式：定义集合数据的遍历规则
访问者模式：分离对象结构与元素的执行算法
-----------------------------------
除了模板方法模式和解释器模式是类行为模式，其他的全部属于对象行为模式



模板方法模式[templateMethod]：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
策略模式[Strategy]：
责任链模式[Chain of Responsibility]：使多个对象都有机会处理请求， 从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链， 并沿着这条链传递该请求， 直到有对象处理它为止；
状态模式[State]：
命令模式[Command]：将一个请求封装成一个对象， 从而让你使用不同的请求把客户端参数化， 对请求排队或者记录请求日志， 可以提供命令的撤销和恢复功能；
备忘录模式[Memento]：通俗地说，备忘录模式就是一个对象的备份模式， 提供了一种程序数据的备份方法；
观察者模式[Observer]：定义对象间一种一对多的依赖关系， 使得每当一个对象改变状态， 则所有依赖于它的对象都会得到通知并被自动更新；
访问者模式[Visitor]：封装一些作用于某种数据结构中的各元素的操作， 它可以在不改变数据结构的前提下定义作用于这些元素的新的操作；
b
中介者模式[Mediator]：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互；
迭代器模式[Iterator]：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节；
解释器模式[Interpreter]：


命令模式 VS 策略模式
策略模式 VS 状态模式
观察者模式 VS 责任链模式
